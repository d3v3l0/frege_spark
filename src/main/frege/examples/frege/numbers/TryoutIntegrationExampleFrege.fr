module examples.frege.numbers.TryoutIntegrationExampleFrege where

import spark.bindings.SparkConf
import bindings.Function
import bindings.Function2
import spark.bindings.custom.CustomFunction
import spark.bindings.custom.TestBindings
import spark.bindings.JavaSparkContext
import spark.config.Config

{- failed native experiment
native module where {
    public static class NativeFunction {
    public static Function<Double, Double> createFunction() {

		return new Function() {
			public Double call(Double x) throws Exception  {
		        System.out.println("Hello World From Java");
                System.out.println("value = " + x);
                return x * 10.0;
			}
		};
	};
  }
}

native createFunction  TryoutIntegrationExampleFrege.NativeFunction.createFunction {a, b } :: () -> ST s (Function a b)
-}

main :: IO ()
main = do
  sparkConfig <- SparkConf.new ()
  println fregecJar
  list <- arrayFromListST [applicationJar, fregecJar, "frege-interpreter-core-1.3-SNAPSHOT.jar"]
  sparkConfig.setAppName "Frege-Spark"
  sparkConfig.setJars list
  sparkConfig.setMaster "local"
  --sparkConfig.setMaster "spark://Damians-MacBook.local:7077"
  sc :: MutableIO JavaSparkContext <- JavaSparkContext.new sparkConfig
  
  currentData <- JavaSparkContext.textFile sc "data/first.csv"
  parsedData <- currentData.map CustomFunction.Function.convertToDouble
  --mappedData <- parsedData.map $ Function.Function.createInterpretedFunction "timesTen"
  mappedData <- parsedData.map $ Function.Function.createFunction ()
 
  sum <- mappedData.reduce $ Function2.createInterpretedFunction "sum"

  currentFirst <- currentData.first
  assertEquals currentFirst "1"

  parsedFirst <- parsedData.first
  assertEquals parsedFirst 1.0

  mappedFirst <- mappedData.first
  assertEquals 10.0 mappedFirst 

  assertEquals 84.0 sum

  scMaster :: String <- sc.master
  println $ "calculated with master: " ++ scMaster
  println "final3"
