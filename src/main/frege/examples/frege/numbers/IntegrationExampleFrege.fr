module examples.frege.numbers.IntegrationExampleFrege where

import spark.bindings.SparkConf
import spark.bindings.custom.Function
import spark.bindings.custom.Function2

import spark.bindings.JavaSparkContext

import frege.test.QuickCheck

appendTest :: String -> String
appendTest x = x ++ "Testdkaa"

filterThreeOrFive :: Double -> Bool
filterThreeOrFive 3.0 = true
filterThreeOrFive 5.0 = true
filterThreeOrFive _ = false


addOne :: Double -> Double
addOne x = x + 1.0

times2 :: Double -> Double
times2 x = x * 2.0

times10 :: Double -> Double
times10 x = x * 10.0

mySum :: Double -> Double -> Double
mySum x y = x + y

main :: IO ()
main = do
  sparkConfig <- SparkConf.new ()
  --"frege3.24.405.jar"
  println "frege3.24.405.jar"
  list <- arrayFromListST ["frege-spark.jar", "frege3.24.405.jar", "frege-interpreter-core-1.3-SNAPSHOT.jar"]
  --sparkConfig.setMaster "local"
  sparkConfig.setMaster "spark://Damians-MacBook.local:7077"
  sparkConfig.setAppName "Frege-Spark"
  sparkConfig.setJars list
  sc :: MutableIO JavaSparkContext <- JavaSparkContext.new sparkConfig

  currentData <- JavaSparkContext.textFile sc "data/first.csv"
--  mappedData <- currentData.map $ Function.createInterpretedFunction ()
  parsedData <- currentData.map Function.convertToDouble
  --mappedData <- parsedData.map $ Function.createInterpretedDoubleFunction ("f x = x + 3")
  --mappedData <- parsedData.map $ Function.create addOne
  --parsedData <- currentData.map Function.convertToDouble
  --myF <- FunctionWrapper.new filterThreeOrFive
  --filteredData <- parsedData.filter $ myF
  mappedData <- parsedData.map $ Function.createInterpretedFunction ("timesTen")
  filteredData <- mappedData.filter $ Function.createInterpretedFunction ("filterThirty")
  mappedData1 <- filteredData.map $ Function.createInterpretedFunction ("addOne")
  --filteredData <- parsedData.filter $ Function.createSerializableFunction filterThreeOrFive
  --mappedData <- filteredData.map $ Function.create addOne  
  --mappedData2 <- mappedData.map $ Function.create times10  
  --mappedData3 <- mappedData2.map $ Function.create times2  
  --sum <- mappedData3.reduce $ Function2.create mySum

  -- print insights and results

  currentFirst <- currentData.first
  
  print $ "currentFirst: "
  println $ currentFirst


  
  parsedFirst <- parsedData.first
  
  print $ "parsedFirst: "
  println $ show $ parsedFirst
  

  mappedFirst :: Double <- mappedData.first
  
  print $ "mappedFirst: "
  println $ mappedFirst
  
  filteredFirst :: Double <-  filteredData.first
  
  print $ "filteredFirst: "
  println $ show $ filteredFirst
  
  
  mapped1First :: Double <- mappedData1.first
  
  print $ "mapped1First: "
  println $ mapped1First
  
  {-
  mapped2First <- mappedData2.first
  
  print $ "mapped2First: "
  println $ mapped2First
  
  mapped3First <- mappedData3.first
  
  print $ "mapped3First: "
  println $ mapped3First
  
  print $ "sum: "
  println $ sum
  -}

  scMaster :: String <- sc.master
  println $ "calculated with master: " ++ scMaster
  println "final2"
